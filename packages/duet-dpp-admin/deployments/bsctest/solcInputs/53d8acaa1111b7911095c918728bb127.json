{
  "language": "Solidity",
  "sources": {
    "contracts/DodoOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IDuetOracle.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Adminable.sol\";\n\ncontract DodoOracle is Adminable, Initializable {\n    // token address => duet oracle\n    mapping(address => IDuetOracle) public duetOracleMapping;\n    /**\n     * fallback oracle for tokens which no oracle in duetOracleMapping\n     */\n    IDuetOracle public fallbackDuetOracle;\n\n    function initialize(address admin_) external initializer {\n        _setAdmin(admin_);\n    }\n\n    function setFallbackDuetOracle(IDuetOracle fallbackDuetOracle_) external onlyAdmin {\n        fallbackDuetOracle = fallbackDuetOracle_;\n    }\n\n    function setDuetOracle(address token_, IDuetOracle duetOracle_) external onlyAdmin {\n        duetOracleMapping[token_] = duetOracle_;\n    }\n\n    function prices(address base_) external view returns (uint256 price) {\n        if (address(duetOracleMapping[base_]) == address(0)) {\n            price = fallbackDuetOracle.getPrice(base_);\n        } else {\n            price = duetOracleMapping[base_].getPrice(base_);\n        }\n        require(price > 0, \"Invalid price from oracle\");\n\n        uint256 baseTokenDecimals = IERC20(base_).decimals();\n        require(baseTokenDecimals < 36, \"decimals of base token is too high\");\n        // decimals for Dodo is `18 - base + quote`\n        // quote token is always BUSD, it is 1e18\n        // duet oracle returns 1e8 value\n        uint256 targetDecimals = uint256(18 - int256(baseTokenDecimals) + 18);\n        if (targetDecimals == 8) {\n            return price;\n        }\n        if (targetDecimals > 8) {\n            return price * 10**(targetDecimals - 8);\n        }\n        return price / (10**(8 - targetDecimals));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDuetOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IDuetOracle {\n    // Must 8 dec, same as chainlink decimals.\n    function getPrice(address token) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/lib/Adminable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nabstract contract Adminable {\n    event AdminUpdated(address indexed user, address indexed newAdmin);\n\n    address public admin;\n\n    modifier onlyAdmin() virtual {\n        require(msg.sender == admin, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function setAdmin(address newAdmin) public virtual onlyAdmin {\n        _setAdmin(newAdmin);\n    }\n\n    function _setAdmin(address newAdmin) internal {\n        require(newAdmin != address(0), \"Can not set admin to zero address\");\n        admin = newAdmin;\n\n        emit AdminUpdated(msg.sender, newAdmin);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockDppRouter.sol": {
      "content": "/*\n    SPDX-License-Identifier: Apache-2.0\n*/\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../lib/Adminable.sol\";\nimport \"../interfaces/IDODOV2.sol\";\n\ncontract DppRouter is Adminable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    mapping(address => mapping(address => address)) public availablePools;\n    mapping(address => bool) public availableBaseToken;\n\n    struct PoolInfo {\n        address baseToken;\n        address quoteToken;\n        address pairAddress;\n    }\n\n    // ============ modifier ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"dppRouter: expired\");\n        _;\n    }\n\n    constructor(address _admin) public {\n        _setAdmin(_admin);\n    }\n\n    function setAvailablePools(PoolInfo[] memory _pools) public onlyAdmin {\n        for (uint256 i = 0; i < _pools.length; ++i) {\n            availablePools[_pools[i].baseToken][_pools[i].quoteToken] = _pools[i].pairAddress;\n        }\n    }\n\n    function setAvailableBaseTokens(address[] calldata _newBaseTokens) public onlyAdmin {\n        for (uint256 i = 0; i < _newBaseTokens.length; ++i) {\n            availableBaseToken[_newBaseTokens[i]] = true;\n        }\n    }\n\n    function delBaseTokens(address[] calldata _delBaseTokens) public onlyAdmin {\n        for (uint256 i = 0; i < _delBaseTokens.length; ++i) {\n            availableBaseToken[_delBaseTokens[i]] = false;\n        }\n    }\n\n    function setOneAvailablePool(\n        address _baseToken,\n        address _quoteToken,\n        address _pairAddress\n    ) public onlyAdmin {\n        availablePools[_baseToken][_quoteToken] = _pairAddress;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external judgeExpired(_deadline) returns (uint256[] memory amounts) {\n        amounts = new uint256[](_path.length);\n        amounts[0] = _amountIn;\n        address V2pair = _getPairAddr(_path[0], _path[1]);\n\n        if (_path[0] == IDODOV2(V2pair)._BASE_TOKEN_()) {\n            // sell base\n            uint256 QuoteOutAmount = querySellBaseToken(_amountIn, V2pair);\n            amounts[_path.length - 1] = QuoteOutAmount;\n            require(QuoteOutAmount >= _amountOutMin, \"dppRouter: receive amount not enough\");\n\n            IERC20Upgradeable(_path[0]).safeTransferFrom(msg.sender, address(this), _amountIn);\n            IERC20Upgradeable(_path[0]).safeTransfer(V2pair, _amountIn);\n            IDODOV2(V2pair).sellBase(_to);\n        } else if (_path[0] == IDODOV2(V2pair)._QUOTE_TOKEN_()) {\n            uint256 BaseOutAmount = querySellQuoteToken(_amountIn, V2pair);\n            amounts[_path.length - 1] = BaseOutAmount;\n            require(BaseOutAmount >= _amountOutMin, \"dppRouter: receive amount not enough\");\n\n            IERC20Upgradeable(_path[0]).safeTransferFrom(msg.sender, address(this), _amountIn);\n            IERC20Upgradeable(_path[0]).safeTransfer(V2pair, _amountIn);\n            IDODOV2(V2pair).sellQuote(_to);\n        }\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBaseToken(uint256 _amount, address _pair) public view returns (uint256 receiveQuote) {\n        (receiveQuote, , , ) = IDODOV2(_pair).querySellBase(address(this), _amount);\n    }\n\n    function querySellQuoteToken(uint256 _amount, address _pair) public view returns (uint256 receiveBase) {\n        (receiveBase, , , ) = IDODOV2(_pair).querySellQuote(address(this), _amount);\n    }\n\n    // =========== internal ===============\n\n    function _getPairAddr(address _sellToken, address _buyToken) internal returns (address V2Pair) {\n        V2Pair = availablePools[_sellToken][_buyToken] != address(0)\n            ? availablePools[_sellToken][_buyToken]\n            : availablePools[_buyToken][_sellToken];\n        require(V2Pair != address(0), \"dppRouter: no pair\");\n        return V2Pair;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDODOV2.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"../external/lib/PMMPricing.sol\";\n\ninterface IDODOV2 {\n    //========== Common ==================\n\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\n\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        external\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        );\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        external\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        );\n\n    function _BASE_TOKEN_() external view returns (address);\n\n    function _QUOTE_TOKEN_() external view returns (address);\n\n    function getPMMStateForCall()\n        external\n        view\n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        );\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory, address[] memory);\n\n    //========== DODOVendingMachine ========\n\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine);\n\n    function buyShares(address to)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    //========== DODOPrivatePool ===========\n\n    function createDODOPrivatePool() external returns (address newPrivatePool);\n\n    function initDODOPrivatePool(\n        address dppAddress,\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 k,\n        uint256 i,\n        bool isOpenTwap\n    ) external;\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function _OWNER_() external returns (address);\n\n    function _LP_FEE_RATE_() external returns (uint64);\n\n    function _K_() external returns (uint64);\n\n    function _I_() external returns (uint128);\n\n    //========== CrowdPooling ===========\n\n    function createCrowdPooling() external returns (address payable newCrowdPooling);\n\n    function initCrowdPooling(\n        address cpAddress,\n        address creator,\n        address[] memory tokens,\n        uint256[] memory timeLine,\n        uint256[] memory valueList,\n        bool[] memory switches,\n        int256 globalQuota\n    ) external;\n\n    function bid(address to) external;\n}\n"
    },
    "contracts/external/lib/PMMPricing.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"../../lib/SafeMath.sol\";\nimport { DecimalMath } from \"../../lib/DecimalMath.sol\";\nimport { DODOMath } from \"./DODOMath.sol\";\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n    using SafeMath for uint256;\n\n    enum RState {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (uint256 receiveQuoteAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0.sub(state.B);\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote.add(\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\n                );\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (uint256 receiveBaseAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else {\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\n            if (payQuoteAmount < backToOnePayQuote) {\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n                newR = RState.BELOW_ONE;\n                if (receiveBaseAmount > backToOneReceiveBase) {\n                    receiveBaseAmount = backToOneReceiveBase;\n                }\n            } else if (payQuoteAmount == backToOnePayQuote) {\n                receiveBaseAmount = backToOneReceiveBase;\n                newR = RState.ONE;\n            } else {\n                receiveBaseAmount = backToOneReceiveBase.add(\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\n                );\n                newR = RState.ABOVE_ONE;\n            }\n        }\n    }\n\n    // ============ R = 1 cases ============\n\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        // in theory Q2 <= targetQuoteTokenAmount\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n        return DODOMath._SolveQuadraticFunctionForTrade(state.Q0, state.Q0, payBaseAmount, state.i, state.K);\n    }\n\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B0,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ R < 1 cases ============\n\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.Q0,\n                state.Q.add(payQuoteAmount),\n                state.Q,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return DODOMath._SolveQuadraticFunctionForTrade(state.Q0, state.Q, payBaseAmount, state.i, state.K);\n    }\n\n    // ============ R > 1 cases ============\n\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return DODOMath._GeneralIntegrate(state.B0, state.B.add(payBaseAmount), state.B, state.i, state.K);\n    }\n\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ Helper functions ============\n\n    function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(state.Q, state.B.sub(state.B0), state.i, state.K);\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q.sub(state.Q0),\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n        if (state.R == RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title SafeMath\n * @author DODO Breeder\n *\n * @notice Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MUL_ERROR\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DIVIDING_ERROR\");\n        return a / b;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = div(a, b);\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_ERROR\");\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_ERROR\");\n        return c;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = x / 2 + 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n"
    },
    "contracts/lib/DecimalMath.sol": {
      "content": "pragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"./SafeMath.sol\";\n\n/**\n * @title DecimalMath\n * @author DODO Breeder\n *\n * @notice Functions for fixed point number with 18 decimals\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant ONE = 10**18;\n    uint256 internal constant ONE2 = 10**36;\n\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d) / (10**18);\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d).divCeil(10**18);\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).div(d);\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).divCeil(d);\n    }\n\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).div(target);\n    }\n\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).divCeil(target);\n    }\n\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\n        if (e == 0) {\n            return 10**18;\n        } else if (e == 1) {\n            return target;\n        } else {\n            uint256 p = powFloor(target, e.div(2));\n            p = p.mul(p) / (10**18);\n            if (e % 2 == 1) {\n                p = p.mul(target) / (10**18);\n            }\n            return p;\n        }\n    }\n}\n"
    },
    "contracts/external/lib/DODOMath.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"../../lib/SafeMath.sol\";\nimport { DecimalMath } from \"../../lib/DecimalMath.sol\";\n\n/**\n * @title DODOMath\n * @author DODO Breeder\n *\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary DODOMath {\n    using SafeMath for uint256;\n\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(\n        uint256 V0,\n        uint256 V1,\n        uint256 V2,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\n        if (k == 0) {\n            return fairAmount.div(DecimalMath.ONE);\n        }\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        if (k == 0) {\n            return V1.add(DecimalMath.mulFloor(i, delta));\n        }\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = âˆš(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n\n        if (V1 == 0) {\n            return 0;\n        }\n        uint256 sqrt;\n        uint256 ki = (4 * k).mul(i);\n        if (ki == 0) {\n            sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\n        } else {\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\n        }\n        uint256 premium = DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(\n        uint256 V0,\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i.mul(delta);\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1).div(V0.mul(V0));\n            } else {\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\n            }\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs.div(DecimalMath.ONE);\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mulFloor(DecimalMath.ONE.sub(k).mul(4), DecimalMath.mulFloor(k, V0).mul(V0)); // 4(1-k)kQ0^2\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot.sub(bAbs);\n        } else {\n            numerator = bAbs.add(squareRoot);\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}\n"
    },
    "contracts/DuetDppLpFunding.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { DecimalMath } from \"./lib/DecimalMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { IDODOV2 } from \"./interfaces/IDODOV2.sol\";\nimport { DuetDppLp } from \"./DuetDppLp.sol\";\n\ncontract DuetDppLpFunding is DuetDppLp, ReentrancyGuard {\n    using SafeMath for uint256;\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n\n    // buy shares [round down]\n    function _buyShares(address to)\n        internal\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(_DPP_ADDRESS_);\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(_DPP_ADDRESS_);\n        (uint256 baseReserve, uint256 quoteReserve) = IDODOV2(_DPP_ADDRESS_).getVaultReserve();\n\n        baseInput = baseBalance.sub(baseReserve);\n        quoteInput = quoteBalance.sub(quoteReserve);\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            require(baseBalance >= 10**3, \"INSUFFICIENT_LIQUIDITY_MINED\");\n            shares = baseBalance; // ä»¥å…å‡ºçŽ°balanceå¾ˆå¤§ä½†shareså¾ˆå°çš„æƒ…å†µ\n        } else if (baseReserve > 0 && quoteReserve == 0) {\n            // case 2. supply when quote reserve is 0\n            shares = baseInput.mul(totalSupply).div(baseReserve);\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 3. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n        }\n        _mint(to, shares);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    // sell shares [round down]\n    function _sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\n        require(shareAmount <= _SHARES_[to], \"DLP_NOT_ENOUGH\");\n        (uint256 baseBalance, uint256 quoteBalance) = IDODOV2(_DPP_ADDRESS_).getVaultReserve();\n        uint256 totalShares = totalSupply;\n\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\n\n        require(baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount, \"WITHDRAW_NOT_ENOUGH\");\n\n        _burn(to, shareAmount);\n\n        emit SellShares(to, to, shareAmount, _SHARES_[to]);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/DuetDppLp.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { DecimalMath } from \"./lib/DecimalMath.sol\";\nimport { DuetDppStorage } from \"./DuetDppStorage.sol\";\n\ncontract DuetDppLp is DuetDppStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Mint(address indexed user, uint256 value);\n\n    event Burn(address indexed user, uint256 value);\n\n    // ============ Shares (ERC20) ============\n\n    /**\n     * @dev transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _SHARES_[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        _SHARES_[from] = _SHARES_[from].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _ALLOWED_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        require(value > 1000, \"MINT_INVALID\");\n        _SHARES_[user] = _SHARES_[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        _SHARES_[user] = _SHARES_[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n\n    // ============================ Permit ======================================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"DODO_DVM_LP: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"DODO_DVM_LP: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/DuetDppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ncontract DuetDppStorage {\n    // ============ pool info ===============\n    address public _DPP_ADDRESS_;\n    address public _DPP_ADMIN_ADDRESS_;\n    IERC20Metadata public _BASE_TOKEN_;\n    IERC20Metadata public _QUOTE_TOKEN_;\n    uint64 public _LP_FEE_RATE_;\n    uint128 public _I_;\n    uint64 public _K_;\n\n    // ============ Shares (ERC20) ============\n\n    string public symbol;\n    uint8 public decimals;\n    string public name;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n\n    // ================= Permit ======================\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/mocks/MockBEP20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockBEP20 is ERC20, Ownable {\n    address public minter;\n\n    modifier onlyMinter() {\n        require(minter == msg.sender, \"Minter only\");\n        _;\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address minter_\n    ) ERC20(name_, symbol_) Ownable() {\n        minter = minter_;\n    }\n\n    function setMinter(address minter_) public onlyOwner {\n        require(minter_ != address(0), \"Cant set minter to zero address\");\n        minter = minter_;\n    }\n\n    function mint(address to_, uint256 amount_) external onlyMinter {\n        require(amount_ > 0, \"Nothing to mint\");\n        _mint(to_, amount_);\n    }\n\n    function burnFrom(address account_, uint256 amount_) external onlyMinter {\n        require(amount_ > 0, \"Nothing to burn\");\n        _burn(account_, amount_);\n    }\n}\n"
    },
    "contracts/lib/UniversalERC20.sol": {
      "content": "pragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function universalTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function universalApproveMax(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 allowance = token.allowance(address(this), to);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, type(uint256).max);\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function tokenBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        return token.balanceOf(who);\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return token == ETH_ADDRESS;\n    }\n}\n"
    },
    "contracts/DuetDPPController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { UniversalERC20 } from \"./lib/UniversalERC20.sol\";\nimport { DecimalMath } from \"./lib/DecimalMath.sol\";\n\nimport { Adminable } from \"./lib/Adminable.sol\";\nimport { IDODOV2 } from \"./interfaces/IDODOV2.sol\";\nimport { IDPPOracleAdmin } from \"./interfaces/IDPPOracleAdmin.sol\";\nimport { IDPPOracle } from \"./interfaces/IDPPOracle.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IOracle } from \"./external/interfaces/IOracle.sol\";\n\nimport { DuetDppLpFunding } from \"./DuetDppLpFunding.sol\";\n\ncontract DuetDppController is Adminable, DuetDppLpFunding {\n    using SafeMath for uint256;\n    using UniversalERC20 for IERC20Metadata;\n    using SafeERC20 for IERC20Metadata;\n\n    address public _WETH_;\n    bool flagInit = false;\n\n    /** ä¸»è¦ç”¨äºŽfrontrunä¿æŠ¤ï¼Œå½“é¡¹ç›®æ–¹å‘èµ·äº¤æ˜“ï¼Œä¿®æ”¹æ± å­å‚æ•°æ—¶ï¼Œå¯èƒ½ä¼šé€ æˆæ± å­çš„ä»·æ ¼æ”¹å˜ï¼Œ\n     * è¿™æ—¶å€™æœºå™¨äººå¯èƒ½ä¼šfrontrunå¥—åˆ©ï¼Œå› æ­¤è¿™ä¸¤ä¸ªå‚æ•°è®¾å®šåŽï¼Œ\n     * å½“æ‰§è¡Œæ—¶æ± å­çŽ°å­˜çš„baseï¼Œquoteçš„æ•°é‡å°äºŽä¼ å…¥çš„å€¼ï¼Œresetäº¤æ˜“ä¼šrevertï¼Œé˜²æ­¢è¢«å¥—åˆ© **/\n    uint256 minBaseReserve = 0;\n    uint256 minQuoteReserve = 0;\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"Duet Dpp Controller: EXPIRED\");\n        _;\n    }\n\n    modifier notInitialized() {\n        require(flagInit == false, \"have been initialized\");\n        flagInit = true;\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    function init(\n        address admin,\n        address dppAddress,\n        address dppAdminAddress,\n        address weth\n    ) external notInitialized {\n        // æ”¹init\n        _WETH_ = weth;\n        _DPP_ADDRESS_ = dppAddress;\n        _DPP_ADMIN_ADDRESS_ = dppAdminAddress;\n        _setAdmin(admin);\n\n        // load pool info\n        _BASE_TOKEN_ = IERC20Metadata(IDODOV2(_DPP_ADDRESS_)._BASE_TOKEN_());\n        _QUOTE_TOKEN_ = IERC20Metadata(IDODOV2(_DPP_ADDRESS_)._QUOTE_TOKEN_());\n        _updateDppInfo();\n\n        string memory connect = \"-\";\n        string memory suffix = \"DuetLP_\";\n\n        name = string(abi.encodePacked(suffix, connect, _BASE_TOKEN_.symbol(), connect, _QUOTE_TOKEN_.symbol()));\n        symbol = \"Duet-LP\";\n        decimals = _BASE_TOKEN_.decimals();\n\n        // ============================== Permit ====================================\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        // ==========================================================================\n    }\n\n    // ========= change DPP Oracle and Parameters , onlyAdmin ==========\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve_,\n        uint256 minQuoteReserve_\n    ) external onlyAdmin returns (bool) {\n        IDPPOracleAdmin(_DPP_ADMIN_ADDRESS_).tunePrice(newI, minBaseReserve_, minQuoteReserve_);\n        _updateDppInfo();\n        return true;\n    }\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve_,\n        uint256 minQuoteReserve_\n    ) external onlyAdmin returns (bool) {\n        IDPPOracleAdmin(_DPP_ADMIN_ADDRESS_).tuneParameters(\n            newLpFeeRate,\n            newI,\n            newK,\n            minBaseReserve_,\n            minQuoteReserve_\n        );\n        _updateDppInfo();\n        return true;\n    }\n\n    function changeOracle(address newOracle) external onlyAdmin {\n        require(IOracle(newOracle).prices(address(_BASE_TOKEN_)) > 0, \"Duet Dpp Controller: invaild oracle price\");\n        IDPPOracleAdmin(_DPP_ADMIN_ADDRESS_).changeOracle(newOracle);\n    }\n\n    function enableOracle() external onlyAdmin {\n        address _O_ = IDPPOracle(_DPP_ADDRESS_)._O_();\n        require(IOracle(_O_).prices(address(_BASE_TOKEN_)) > 0, \"Duet Dpp Controller: invaild oracle price\");\n        IDPPOracleAdmin(_DPP_ADMIN_ADDRESS_).enableOracle();\n    }\n\n    function disableOracle(uint256 newI) external onlyAdmin {\n        require(newI > 0, \"Duet Dpp Controller: invaild new I\");\n        IDPPOracleAdmin(_DPP_ADMIN_ADDRESS_).disableOracle(newI);\n    }\n\n    function changeMinRes(uint256 newBaseR_, uint256 newQuoteR_) external onlyAdmin {\n        minBaseReserve = newBaseR_;\n        minQuoteReserve = newQuoteR_;\n    }\n\n    // =========== deal with LP ===============\n\n    function addDuetDppLiquidity(\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\n        uint256 deadLine\n    )\n        external\n        payable\n        nonReentrant\n        judgeExpired(deadLine)\n        returns (\n            uint256 shares,\n            uint256 baseAdjustedInAmount,\n            uint256 quoteAdjustedInAmount\n        )\n    {\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustedAddLiquidityInAmount(baseInAmount, quoteInAmount);\n        require(\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\n            \"Duet Dpp Controller: deposit amount is not enough\"\n        );\n\n        _deposit(msg.sender, _DPP_ADDRESS_, IDODOV2(_DPP_ADDRESS_)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\n        _deposit(msg.sender, _DPP_ADDRESS_, IDODOV2(_DPP_ADDRESS_)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\n\n        //mint lp tokens to users\n\n        (shares, , ) = _buyShares(msg.sender);\n        // reset dpp pool\n        require(\n            IDODOV2(IDODOV2(_DPP_ADDRESS_)._OWNER_()).reset(\n                address(this),\n                _LP_FEE_RATE_,\n                _I_,\n                _K_,\n                0, //baseOutAmount, add liquidity so outAmount is 0\n                0, //quoteOutAmount, add liquidity so outAmount is 0\n                minBaseReserve, // minBaseReserve\n                minQuoteReserve // minQuoteReserve\n            ),\n            \"Duet Dpp Controller: Reset Failed\"\n        );\n\n        // refund dust eth\n        if (flag == 1 && msg.value > baseAdjustedInAmount) {\n            payable(msg.sender).transfer(msg.value - baseAdjustedInAmount);\n        }\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) {\n            payable(msg.sender).transfer(msg.value - quoteAdjustedInAmount);\n        }\n    }\n\n    function removeDuetDppLiquidity(\n        uint256 shareAmount,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n        uint256 deadLine\n    )\n        external\n        nonReentrant\n        judgeExpired(deadLine)\n        returns (\n            uint256 shares,\n            uint256 baseOutAmount,\n            uint256 quoteOutAmount\n        )\n    {\n        //mint lp tokens to users\n        (baseOutAmount, quoteOutAmount) = _sellShares(shareAmount, msg.sender, baseMinAmount, quoteMinAmount);\n        // reset dpp pool\n        require(\n            IDODOV2(IDODOV2(_DPP_ADDRESS_)._OWNER_()).reset(\n                address(this),\n                _LP_FEE_RATE_,\n                _I_,\n                _K_,\n                baseOutAmount,\n                quoteOutAmount,\n                minBaseReserve, //minBaseReserve,\n                minQuoteReserve //minQuoteReserve\n            ),\n            \"Duet Dpp Controller: Reset Failed\"\n        );\n\n        _withdraw(payable(msg.sender), IDODOV2(_DPP_ADDRESS_)._BASE_TOKEN_(), baseOutAmount, flag == 3);\n        _withdraw(payable(msg.sender), IDODOV2(_DPP_ADDRESS_)._QUOTE_TOKEN_(), quoteOutAmount, flag == 4);\n        shares = shareAmount;\n    }\n\n    function _adjustedAddLiquidityInAmount(uint256 baseInAmount, uint256 quoteInAmount)\n        internal\n        view\n        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount)\n    {\n        (uint256 baseReserve, uint256 quoteReserve) = IDODOV2(_DPP_ADDRESS_).getVaultReserve();\n        if (quoteReserve == 0 && baseReserve == 0) {\n            require(msg.sender == admin, \"Duet Dpp Controller: Must initialized by admin\");\n            // Must initialized by admin\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = quoteInAmount;\n        }\n        if (quoteReserve == 0 && baseReserve > 0) {\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = 0;\n        }\n        if (quoteReserve > 0 && baseReserve > 0) {\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n            }\n        }\n    }\n\n    function _calRecommendAmounts(\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint8 flag // flag=0 is baseIn fixed, flag=1 is quoteIn fixed\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        (uint256 baseReserve, uint256 quoteReserve) = IDODOV2(_DPP_ADDRESS_).getVaultReserve();\n        if (quoteReserve == 0 && baseReserve == 0) {\n            require(msg.sender == admin, \"Duet Dpp Controller: Must initialized by admin\");\n            // Must initialized by admin\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = quoteInAmount;\n        }\n        if (quoteReserve == 0 && baseReserve > 0) {\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = 0;\n        }\n        if (quoteReserve > 0 && baseReserve > 0) {\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (flag == 0) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n            }\n        }\n    }\n\n    function recommendQuoteInAmount(uint256 baseInAmount_)\n        external\n        view\n        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount)\n    {\n        return _calRecommendAmounts(baseInAmount_, 0, 0);\n    }\n\n    function recommendBaseInAmount(uint256 quoteInAmount_)\n        external\n        view\n        returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount)\n    {\n        return _calRecommendAmounts(0, quoteInAmount_, 1);\n    }\n\n    function recommendBaseAndQuote(uint256 shareAmount_)\n        external\n        view\n        returns (uint256 baseAmount, uint256 quoteAmount)\n    {\n        (uint256 baseBalance, uint256 quoteBalance) = IDODOV2(_DPP_ADDRESS_).getVaultReserve();\n        uint256 totalShares = totalSupply;\n\n        baseAmount = baseBalance.mul(shareAmount_).div(totalShares);\n        quoteAmount = quoteBalance.mul(shareAmount_).div(totalShares);\n    }\n\n    // ================= internal ====================\n\n    function _updateDppInfo() internal {\n        _LP_FEE_RATE_ = IDODOV2(_DPP_ADDRESS_)._LP_FEE_RATE_();\n        _K_ = IDODOV2(_DPP_ADDRESS_)._K_();\n        _I_ = IDODOV2(_DPP_ADDRESS_)._I_();\n    }\n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value >= amount, \"ETH_VALUE_WRONG\");\n                // case:msg.value > adjustAmount\n                IWETH(_WETH_).deposit{ value: amount }();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20Metadata(_WETH_), to, amount);\n            }\n        } else {\n            if (amount > 0) {\n                IERC20Metadata(token).safeTransferFrom(from, to, amount);\n            }\n        }\n    }\n\n    function _withdraw(\n        address payable to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).withdraw(amount);\n                to.transfer(amount);\n            }\n        } else {\n            if (amount > 0) {\n                IERC20Metadata(token).safeTransfer(to, amount);\n            }\n        }\n    }\n\n    // =================================================\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n}\n"
    },
    "contracts/interfaces/IDPPOracleAdmin.sol": {
      "content": "pragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPOracleAdmin {\n    function init(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) external;\n\n    //=========== admin ==========\n    function ratioSync() external;\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external;\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function changeOracle(address newOracle) external;\n\n    function enableOracle() external;\n\n    function disableOracle(uint256 newI) external;\n}\n"
    },
    "contracts/interfaces/IDPPOracle.sol": {
      "content": "pragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPOracle {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        address o,\n        bool isOpenTWAP,\n        bool isOracleEnabled\n    ) external;\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    function _O_() external returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IWETH {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/external/interfaces/IOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    function getPrice(address base)\n        external\n        view\n        returns (\n            uint256 latestPrice,\n            bool isValid,\n            bool isStale,\n            uint256 timestamp\n        );\n\n    function prices(address base) external view returns (uint256);\n\n    function isFeasible(address base) external view returns (bool);\n}\n"
    },
    "contracts/external/DPPOracle/WooOracleAdapter.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ninterface IWooracle {\n    function timestamp() external view returns (uint256);\n\n    function isFeasible(address base) external view returns (bool);\n\n    function getPrice(address base) external view returns (uint256);\n\n    function price(address base) external view returns (uint256 priceNow, bool feasible);\n}\n\ncontract WooOracleAdapter is IOracle {\n    IWooracle public oracle;\n\n    constructor(address oracleAddress) public {\n        oracle = IWooracle(oracleAddress);\n    }\n\n    function getPrice(address base)\n        external\n        view\n        override\n        returns (\n            uint256 latestPrice,\n            bool isValid,\n            bool isStale,\n            uint256 timestamp\n        )\n    {\n        latestPrice = oracle.getPrice(base);\n        isValid = oracle.isFeasible(base);\n        isStale = !isValid;\n        timestamp = oracle.timestamp();\n        return (latestPrice, isValid, isStale, timestamp);\n    }\n\n    function prices(address base) external view override returns (uint256) {\n        require(oracle.isFeasible(base), \"ORACLE NOT FEASIBLE\");\n        return oracle.getPrice(base);\n    }\n\n    function isFeasible(address base) external view override returns (bool) {\n        return oracle.isFeasible(base);\n    }\n}\n"
    },
    "contracts/external/DPPOracle/DPPStorage.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { InitializableOwnable } from \"../../lib/InitializableOwnable.sol\";\nimport { SafeMath } from \"../../lib/SafeMath.sol\";\nimport { DecimalMath } from \"../../lib/DecimalMath.sol\";\nimport { ReentrancyGuard } from \"../../lib/ReentrancyGuard.sol\";\nimport { IFeeRateModel } from \"../lib/FeeRateModel.sol\";\nimport { IERC20 } from \"../../interfaces/IERC20.sol\";\nimport { PMMPricing } from \"../lib/PMMPricing.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract DPPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public _IS_OPEN_TWAP_ = false;\n    bool public _IS_ORACLE_ENABLED = true;\n\n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // ============ Variables for Pricing ============\n\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n\n    uint64 public _LP_FEE_RATE_;\n    uint64 public _K_;\n    uint128 public _I_;\n    address public _O_;\n\n    // ============ Helper Functions ============\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        if (_IS_ORACLE_ENABLED) {\n            state.i = IOracle(_O_).prices(address(_BASE_TOKEN_));\n        } else {\n            state.i = _I_;\n        }\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_;\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall()\n        external\n        view\n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n}\n"
    },
    "contracts/lib/InitializableOwnable.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/lib/ReentrancyGuard.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ReentrancyGuard\n * @author DODO Breeder\n *\n * @notice Protect functions from Reentrancy Attack\n */\ncontract ReentrancyGuard {\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n    // zero-state of _ENTERED_ is false\n    bool private _ENTERED_;\n\n    modifier preventReentrant() {\n        require(!_ENTERED_, \"REENTRANT\");\n        _ENTERED_ = true;\n        _;\n        _ENTERED_ = false;\n    }\n}\n"
    },
    "contracts/external/lib/FeeRateModel.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { InitializableOwnable } from \"../../lib/InitializableOwnable.sol\";\n\ninterface IFeeRateImpl {\n    function getFeeRate(address pool, address trader) external view returns (uint256);\n}\n\ninterface IFeeRateModel {\n    function getFeeRate(address trader) external view returns (uint256);\n}\n\ncontract FeeRateModel is InitializableOwnable {\n    address public feeRateImpl;\n\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n        feeRateImpl = _feeRateImpl;\n    }\n\n    function getFeeRate(address trader) external view returns (uint256) {\n        if (feeRateImpl == address(0)) return 0;\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender, trader);\n    }\n}\n"
    },
    "contracts/external/DPPOracle/DPPVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { DPPStorage } from \"./DPPStorage.sol\";\nimport { IERC20 } from \"../../interfaces/IERC20.sol\";\nimport { IDODOCallee } from \"../interfaces/IDODOCallee.sol\";\nimport { SafeMath } from \"../../lib/SafeMath.sol\";\nimport { DecimalMath } from \"../../lib/DecimalMath.sol\";\nimport { SafeERC20 } from \"../../lib/SafeERC20.sol\";\nimport { PMMPricing } from \"../lib/PMMPricing.sol\";\n\ncontract DPPVault is DPPStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event LpFeeRateChange(uint256 newLpFeeRate);\n\n    // ============ View Functions ============\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Get Input ============\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set Status ============\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        require(baseReserve <= type(uint112).max && quoteReserve <= type(uint112).max, \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= type(uint112).max && quoteBalance <= type(uint112).max, \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _resetTargetAndReserve() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= type(uint112).max && quoteBalance <= type(uint112).max, \"OVERFLOW\");\n\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function ratioSync() external preventReentrant onlyOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= type(uint112).max && quoteBalance <= type(uint112).max, \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).mul(baseBalance).div(uint256(_BASE_RESERVE_)));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).mul(quoteBalance).div(uint256(_QUOTE_RESERVE_)));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(_BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve, \"RESERVE_AMOUNT_IS_NOT_ENOUGH\");\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        _resetTargetAndReserve();\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function retrieve(\n        address to,\n        address token,\n        uint256 amount\n    ) external preventReentrant onlyOwner {\n        require(token != address(_BASE_TOKEN_) && token != address(_QUOTE_TOKEN_), \"USE_RESET\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/external/interfaces/IDODOCallee.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOCallee {\n    function DVMSellShareCall(\n        address sender,\n        uint256 burnShareAmount,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DVMFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DSPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function CPCancelCall(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function CPClaimBidCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function NFTRedeemCall(\n        address payable assetTo,\n        uint256 quoteAmount,\n        bytes calldata\n    ) external;\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n    This is a simplified version of OpenZepplin's SafeERC20 library\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\nimport { SafeMath } from \"./SafeMath.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/external/DPPOracle/DPPTrader.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { DPPVault } from \"./DPPVault.sol\";\nimport { SafeMath } from \"../../lib/SafeMath.sol\";\nimport { DecimalMath } from \"../../lib/DecimalMath.sol\";\nimport { PMMPricing } from \"../lib/PMMPricing.sol\";\nimport { IDODOCallee } from \"../interfaces/IDODOCallee.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\n\ncontract DPPTrader is DPPVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n\n    function sellBase(address to) external preventReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);\n    }\n\n    function sellQuote(address to) external preventReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        address assetTo = _assetTo;\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0) IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        require(baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_, \"FLASH_LOAN_FAILED\");\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount.sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate)).sub(mtFee);\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount.sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate)).sub(mtFee);\n        newQuoteTarget = state.Q0;\n    }\n}\n"
    },
    "contracts/external/DPPOracle/DPPOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IFeeRateModel } from \"../lib/FeeRateModel.sol\";\nimport { IERC20 } from \"../../interfaces/IERC20.sol\";\nimport { DPPTrader } from \"./DPPTrader.sol\";\n\n/**\n * @title DODO PrivatePool\n * @author DODO Breeder\n *\n * @notice DODOPrivatePool with oracle price\n */\ncontract DPPOracle is DPPTrader {\n    event EnableOracle();\n    event DisableOracle(uint256 newI);\n    event ChangeOracle(address indexed oracle);\n\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        address o,\n        bool isOpenTWAP,\n        bool isOracleEnabled\n    ) external {\n        initOwner(owner);\n\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        _MAINTAINER_ = maintainer;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n\n        require(lpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(k <= 1e18, \"K_OUT_OF_RANGE\");\n        require(i > 0 && i <= 1e36, \"I_OUT_OF_RANGE\");\n        require(o != address(0), \"INVALID_ORACLE\");\n\n        _LP_FEE_RATE_ = uint64(lpFeeRate);\n        _K_ = uint64(k);\n        _I_ = uint128(i);\n        _O_ = o;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        _IS_ORACLE_ENABLED = isOracleEnabled;\n        if (isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n\n        _resetTargetAndReserve();\n    }\n\n    function changeOracle(address newOracle) public preventReentrant onlyOwner {\n        require(newOracle != address(0), \"INVALID_ORACLE\");\n        _O_ = newOracle;\n        emit ChangeOracle(newOracle);\n    }\n\n    function enableOracle() public preventReentrant onlyOwner {\n        _IS_ORACLE_ENABLED = true;\n        emit EnableOracle();\n    }\n\n    function disableOracle(uint256 newI) public preventReentrant onlyOwner {\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        _IS_ORACLE_ENABLED = false;\n        emit DisableOracle(newI);\n    }\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(_BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve, \"RESERVE_AMOUNT_IS_NOT_ENOUGH\");\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(_BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve, \"RESERVE_AMOUNT_IS_NOT_ENOUGH\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        return true;\n    }\n\n    // ============ Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPP Oracle 1.1.0\";\n    }\n}\n"
    },
    "contracts/external/DPPOracle/DPPOracleAdmin.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport { IDPPOracle } from \"../interfaces/IDPPOracle.sol\";\nimport { IDODOApproveProxy } from \"../interfaces/IDODOApproveProxy.sol\";\nimport { InitializableOwnable } from \"../../lib/InitializableOwnable.sol\";\n\n/**\n * @title DPPOracleAdmin\n * @author DODO Breeder\n *\n * @notice Admin of Oracle DODOPrivatePool\n */\ncontract DPPOracleAdmin is InitializableOwnable {\n    address public _DPP_;\n    address public _OPERATOR_;\n    address public _DODO_APPROVE_PROXY_;\n    uint256 public _FREEZE_TIMESTAMP_;\n\n    modifier notFreezed() {\n        require(block.timestamp >= _FREEZE_TIMESTAMP_, \"ADMIN_FREEZED\");\n        _;\n    }\n\n    function init(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) external {\n        initOwner(owner);\n        _DPP_ = dpp;\n        _OPERATOR_ = operator;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    function sync() external notFreezed onlyOwner {\n        IDPPOracle(_DPP_).ratioSync();\n    }\n\n    function setFreezeTimestamp(uint256 timestamp) external notFreezed onlyOwner {\n        _FREEZE_TIMESTAMP_ = timestamp;\n    }\n\n    function setOperator(address newOperator) external notFreezed onlyOwner {\n        _OPERATOR_ = newOperator;\n    }\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external notFreezed onlyOwner {\n        IDPPOracle(_DPP_).retrieve(to, token, amount);\n    }\n\n    function changeOracle(address newOracle) external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).changeOracle(newOracle);\n    }\n\n    function enableOracle() external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).enableOracle();\n    }\n\n    function disableOracle(uint256 newI) external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).disableOracle(newI);\n    }\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external onlyOwner notFreezed returns (bool) {\n        return IDPPOracle(_DPP_).tuneParameters(newLpFeeRate, newI, newK, minBaseReserve, minQuoteReserve);\n    }\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external onlyOwner notFreezed returns (bool) {\n        return IDPPOracle(_DPP_).tunePrice(newI, minBaseReserve, minQuoteReserve);\n    }\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) && operator == _OPERATOR_),\n            \"RESET FORBIDDEN!\"\n        );\n        // only allow owner directly call or operator call via DODODppProxy\n        return\n            IDPPOracle(_DPP_).reset(\n                msg.sender, //only support asset transfer to msg.sender (_OWNER_ or allowed proxy)\n                newLpFeeRate,\n                newI,\n                newK,\n                baseOutAmount,\n                quoteOutAmount,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    // ============ Admin Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPPOracle Admin 1.1.1\";\n    }\n}\n"
    },
    "contracts/external/interfaces/IDPPOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPOracle {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        address o,\n        bool isOpenTWAP,\n        bool isOracleEnabled\n    ) external;\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    //=========== admin ==========\n    function ratioSync() external;\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external;\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function changeOracle(address newOracle) external;\n\n    function enableOracle() external;\n\n    function disableOracle(uint256 newI) external;\n}\n"
    },
    "contracts/external/interfaces/IDODOApproveProxy.sol": {
      "content": "pragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOApproveProxy {\n    function isAllowedProxy(address _proxy) external view returns (bool);\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/factory/DuetDppFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ICloneFactory } from \"../lib/CloneFactory.sol\";\nimport { IDPPOracle } from \"../interfaces/IDPPOracle.sol\";\nimport { IDPPController } from \"../interfaces/IDPPController.sol\";\nimport { IDPPOracleAdmin } from \"../interfaces/IDPPOracleAdmin.sol\";\nimport \"../lib/Adminable.sol\";\n\ncontract DuetDPPFactory is Adminable, Initializable {\n    // ============ default ============\n\n    address public CLONE_FACTORY;\n    address public WETH;\n    address public dodoDefautMtFeeRateModel;\n    address public dodoApproveProxy;\n    address public dodoDefaultMaintainer;\n\n    // ============ Templates ============\n\n    address public dppTemplate;\n    address public dppAdminTemplate;\n    address public dppControllerTemplate;\n\n    // ============registry and adminlist ==========\n\n    // base->quote->dppController\n    mapping(address => mapping(address => address)) public registry;\n    // registry dppController\n    mapping(address => address[]) public userRegistry;\n\n    // ============ Events ============\n\n    event NewDPP(address baseToken, address quoteToken, address creator, address dpp, address dppController);\n\n    function initialize(\n        address admin_,\n        address cloneFactory_,\n        address dppTemplate_,\n        address dppAdminTemplate_,\n        address dppControllerTemplate_,\n        address defaultMaintainer_,\n        address defaultMtFeeRateModel_,\n        address dodoApproveProxy_,\n        address weth_\n    ) public initializer {\n        _setAdmin(admin_);\n        WETH = weth_;\n\n        CLONE_FACTORY = cloneFactory_;\n        dppTemplate = dppTemplate_;\n        dppAdminTemplate = dppAdminTemplate_;\n        dppControllerTemplate = dppControllerTemplate_;\n\n        dodoDefaultMaintainer = defaultMaintainer_;\n        dodoDefautMtFeeRateModel = defaultMtFeeRateModel_;\n        dodoApproveProxy = dodoApproveProxy_;\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function updateDefaultMaintainer(address newMaintainer_) external onlyAdmin {\n        dodoDefaultMaintainer = newMaintainer_;\n    }\n\n    function updateDefaultFeeModel(address newFeeModel_) external onlyAdmin {\n        dodoDefautMtFeeRateModel = newFeeModel_;\n    }\n\n    function updateDodoApprove(address newDodoApprove_) external onlyAdmin {\n        dodoApproveProxy = newDodoApprove_;\n    }\n\n    function updateDppTemplate(address newDPPTemplate_) external onlyAdmin {\n        dppTemplate = newDPPTemplate_;\n    }\n\n    function updateAdminTemplate(address newDPPAdminTemplate_) external onlyAdmin {\n        dppAdminTemplate = newDPPAdminTemplate_;\n    }\n\n    function updateControllerTemplate(address newController_) external onlyAdmin {\n        dppControllerTemplate = newController_;\n    }\n\n    function delOnePool(\n        address baseToken_,\n        address quoteToken_,\n        address dppCtrlAddress_,\n        address creator_\n    ) external onlyAdmin {\n        registry[baseToken_][quoteToken_] = address(0);\n        uint256 len = userRegistry[creator_].length;\n        for (uint256 i = 0; i < len; ++i) {\n            if (userRegistry[creator_][i] == dppCtrlAddress_) {\n                userRegistry[creator_][i] = userRegistry[creator_][len - 1];\n                userRegistry[creator_].pop();\n\n                break;\n            }\n        }\n    }\n\n    // ============ Functions ============\n\n    function _createDODOPrivatePool() internal returns (address newPrivatePool) {\n        newPrivatePool = ICloneFactory(CLONE_FACTORY).clone(dppTemplate);\n    }\n\n    function _createDPPAdminModel() internal returns (address newDppAdminModel) {\n        newDppAdminModel = ICloneFactory(CLONE_FACTORY).clone(dppAdminTemplate);\n    }\n\n    function createDPPController(\n        address creator_, // dpp controller's admin and dppAdmin's operator\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_, // å•ä½æ˜¯10**18ï¼ŒèŒƒå›´æ˜¯[0,10**18] ï¼Œä»£è¡¨çš„æ˜¯äº¤æ˜“æ‰‹ç»­è´¹\n        uint256 k_, // adjust curve's type, limit in [0ï¼Œ10**18], å•ä½æ˜¯ 10**18ï¼Œä»£è¡¨ä»·æ ¼æ›²çº¿æ³¢åŠ¨ç³»æ•° 0æ˜¯æ’å®šä»·æ ¼å–å¸ï¼Œ10**18æ˜¯ç±»UNIçš„bonding curve\n        uint256 i_, // ä»£è¡¨çš„æ˜¯base å¯¹ quoteçš„ä»·æ ¼æ¯”ä¾‹.decimals 18 - baseTokenDecimals+ quoteTokenDecimals. If use oracle, i set here wouldn't be used.\n        address o_, // oracle address\n        bool isOpenTwap_, // use twap price or not\n        bool isOracleEnabled_ // use oracle or not\n    ) external onlyAdmin {\n        require(\n            registry[baseToken_][quoteToken_] == address(0) && registry[quoteToken_][baseToken_] == address(0),\n            \"HAVE CREATED\"\n        );\n        address dppAddress;\n        address dppController;\n        {\n            dppAddress = _createDODOPrivatePool();\n            address dppAdminModel = _createDPPAdminModel();\n            IDPPOracle(dppAddress).init(\n                dppAdminModel,\n                dodoDefaultMaintainer,\n                baseToken_,\n                quoteToken_,\n                lpFeeRate_,\n                dodoDefautMtFeeRateModel,\n                k_,\n                i_,\n                o_,\n                isOpenTwap_,\n                isOracleEnabled_\n            );\n\n            dppController = _createDPPController(creator_, dppAddress, dppAdminModel);\n\n            IDPPOracleAdmin(dppAdminModel).init(\n                dppController, // owner\n                dppAddress,\n                dppController, // del dpp admin's operator\n                dodoApproveProxy\n            );\n        }\n\n        registry[baseToken_][quoteToken_] = dppController;\n        userRegistry[creator_].push(dppController);\n        emit NewDPP(baseToken_, quoteToken_, creator_, dppAddress, dppController);\n    }\n\n    function _createDPPController(\n        address admin_,\n        address dppAddress_,\n        address dppAdminAddress_\n    ) internal returns (address dppController) {\n        dppController = ICloneFactory(CLONE_FACTORY).clone(dppControllerTemplate);\n        IDPPController(dppController).init(admin_, dppAddress_, dppAdminAddress_, WETH);\n    }\n}\n"
    },
    "contracts/lib/CloneFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface ICloneFactory {\n    function clone(address prototype) external returns (address proxy);\n}\n\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\n\ncontract CloneFactory is ICloneFactory {\n    function clone(address prototype) external override returns (address proxy) {\n        bytes20 targetBytes = bytes20(prototype);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n        return proxy;\n    }\n}\n"
    },
    "contracts/interfaces/IDPPController.sol": {
      "content": "pragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPController {\n    function init(\n        address admin,\n        address dppAddress,\n        address dppAdminAddress,\n        address weth\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}