/**
 *  {ROOT}/[namespace]/[chainAlias]/{DELIVERABLE}
 *
 *  type DELIVERABLE = {
 *    chain
 *    contracts: {
 *      [name]: { address, type, abi }
 *    }[]
 *  }
 *
 *  naming DELIVERABLE = `@duet/contract-client-ethers-v5-${namespace}-${chainAlias}`
 *
 *  versioning DELIVERABLE = FOLLOW `duet-contract` or ALWAYS_LATEST
 *
 *  directory DELIVERABLE = `
 *    - lib/factories   # generated by "typechain"
 *      - ...
 *      - index.js  # indexing entry
 *    - lib/index.js    # main entry. shall bootstrapping factories and addresses which generate by this script
 *    - package.json, tsconfig.json, ...
 *  `
 *
 *  method DELIVERABLE = npm-registry, s3-liked, local-tar (for local dev)
 */

import { spawn, } from 'child_process'
import { mkdir, readdir, readFile, rm, writeFile } from 'fs/promises'
import { basename, resolve } from 'path'
import { copy } from 'fs-extra'
import { createSourceFile, ScriptTarget, ScriptKind, SyntaxKind, ExportDeclaration, NamedExports, SourceFile } from 'typescript'
import { config } from 'dotenv'
import { S3 } from '@aws-sdk/client-s3'
import { createReadStream } from 'fs'


const root = resolve(__dirname, '..')
const deliverPath = `${root}/client`
const typeChainPath = `${root}/typechain`
const deploymentsPath = `${root}/deployments`
const contractNamespace = basename(root)

config()

const uploadingChainAliasesBlacklist = ['local', 'localhost', 'dev', 'development', 'test', 'hardhat']


void (async () => {
  await rm(deliverPath, { recursive: true, force: true })

  const typeChainIndex = `${typeChainPath}/index.ts`
  const sourceFile = createSourceFile(
    typeChainIndex,
    (await readFile(typeChainIndex)).toString(),
    ScriptTarget.Latest,
    false,
    ScriptKind.TS
  )
  const exporting = new Set([...loadExportableContractNames(sourceFile)])

  for (const name of await readdir(deploymentsPath)) {
    if (name.startsWith('.')) continue
    const { chain, contracts } = await ensureDeploymentMetaIndex(`${deploymentsPath}/${name}`)

    const packageName = `contract-client-ethers-v5-${contractNamespace}-${chain.alias}`
    const packageRoot = `${deliverPath}/${packageName}`
    await mkdir(`${packageRoot}/src`, { recursive: true })

    let indexContent = `// Auto generated by ${__filename}\n`
    indexContent += `import type { Provider } from '@ethersproject/providers'\n`
    indexContent += `import type { Signer } from 'ethers'\n`
    indexContent += `\n\n`
    indexContent += `export interface PackagedContractsChain {\n`
    indexContent += `  id: number\n`
    indexContent += `  alias: string\n`
    indexContent += `}\n`
    indexContent += `export interface PackagedContractsListItem {\n`
    indexContent += `  class: string\n`
    indexContent += `  instance: string\n`
    indexContent += `  address: string\n`
    indexContent += `}\n`
    indexContent += `\n\n`

    const exportedTypes = new Set<string>()
    for (const contract of contracts) {
      if (!exporting.has(contract.class)) throw new Error(`[${name}] Can not resolve "${contract.class}"`)
      if (!exporting.has(`${contract.class}__factory`)) throw new Error(`[${name}] Can not resolve "${contract.class}" factory`)
      if (!exportedTypes.has(contract.class)) indexContent += `export type { ${contract.class} } from './typechain/index'\n`
      exportedTypes.add(contract.class)
    }
    indexContent += '\n'

    const importedFactories = new Set<string>()
    for (const contract of contracts) {
      indexContent += '\n'
      if (!importedFactories.has(contract.class)) indexContent += `import { ${contract.class}__factory } from './typechain/index'\n`
      importedFactories.add(contract.class)
      indexContent += `export function createContract__${contract.instance}(signerOrProvider: Signer | Provider) {\n`
      indexContent += `  return ${contract.class}__factory.connect('${contract.address}', signerOrProvider)\n`
      indexContent += `}\n`
      indexContent += '\n'
    }
    indexContent += '\n'

    await copy(`${typeChainPath}`, `${packageRoot}/src/typechain`)
    await Promise.all([
      writeFile(`${packageRoot}/package.json`, JSON.stringify({
        name: `@duet-protocol/${packageName}`,
        main: 'lib/index.js',
        // type: 'module',
        license: 'GPL-3.0',
        files: ['chain.json', 'contracts.json', 'lib', 'tsconfig.json'],
        "peerDependencies": {
          "ethers": "^5.5.0",
          "@ethersproject/providers": "^5.5.0",
        },
        version: '0.0.0-t' + Date.now(),
      }, null, 2)),
      writeFile(`${packageRoot}/chain.json`, JSON.stringify(chain, null, 2)),
      writeFile(`${packageRoot}/contracts.json`, JSON.stringify(contracts, null, 2)),
      writeFile(`${packageRoot}/src/index.ts`, indexContent),
      writeFile(`${packageRoot}/tsconfig.json`, JSON.stringify({
        "compilerOptions": {
          "moduleResolution": "node",
          "target": "ES2021",
          // "module": "ESNext",
          "module": "CommonJS",
          "strict": true,
          "skipLibCheck": true,
          "declaration": true,
          "baseUrl": "./src",
          "outDir": "./lib",
        },
      }, null, 2)),
    ])

    await new Promise<void>((res, rej) => {
      spawn(resolve(root, '../..', 'node_modules/.bin/tsc'), { cwd: packageRoot, stdio: 'inherit' })
        .on('close', (code) => {
          if (code) rej(new Error(`Failed by "${code}"`))
          else res()
        })
    })
    await Promise.all(
      (await readdir(`${packageRoot}/src/typechain`)).map(name => {
        if (name.startsWith('.') || !name.endsWith('.d.ts')) return
        return copy(`${packageRoot}/src/typechain/${name}`, `${packageRoot}/lib/typechain/${name}`)
      })
    )

    console.info(`Built package "${packageName}"`)
    if (uploadingChainAliasesBlacklist.includes(chain.alias)) {
      console.info('Won\'t upload to S3')
      continue
    }

    await new Promise<void>((res, rej) => {
      spawn('tar', ['-czf', `../${packageName}.tar.gz`, '.'], { cwd: packageRoot, stdio: 'inherit' })
        .on('close', (code) => {
          if (code) rej(new Error(`Failed by "${code}"`))
          else res()
        })
    })
    const { AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_S3_BUCKET, AWS_REGION } = process.env;
    await new S3({
      region: AWS_REGION, accessKeyId: AWS_ACCESS_KEY_ID, secretAccessKey: AWS_SECRET_ACCESS_KEY
    } as any).putObject({
      Bucket: AWS_S3_BUCKET,
      Key: `${packageName}.tar.gz`,
      Body: createReadStream(`${deliverPath}/${packageName}.tar.gz`),
      ContentType: `application/tar+gzip`,
    })
    console.info('Uploaded to S3')

  }

})()



/**
 * should be replaced by deploy-stage-generated meta index
 */
async function ensureDeploymentMetaIndex(directory: string) {
  const chainId = parseInt((await readFile(`${directory}/.chainId`)).toString(), 10)
  if (isNaN(chainId) && chainId <= 0) throw new Error(`Invalid chain id of ${directory}`)
  const chainAlias = basename(directory)

  const contracts: { class: string, instance: string, address: string }[] = []
  for (const name of await readdir(`${directory}/.extraMeta`)) {
    if (name.startsWith('.') || !name.endsWith('.json')) continue
    const base = JSON.parse((await readFile(`${directory}/.extraMeta/${name}`)).toString())
    const { address } = JSON.parse((await readFile(`${directory}/${name}`)).toString())
    contracts.push({ ...base, address })
  }

  return { chain: { id: chainId, alias: chainAlias }, contracts }
}


function* loadExportableContractNames(sourceFile: SourceFile) {
  for (const statement of sourceFile.statements) {
    if (statement.kind === SyntaxKind.ExportDeclaration) {
      const exporting = statement as ExportDeclaration
      if (exporting.exportClause?.kind === SyntaxKind.NamedExports) {
        const namedExporting = exporting.exportClause as NamedExports
        for (const { name: { escapedText } } of namedExporting.elements) {
          yield escapedText as string
        }
      }
    }
  }
}
